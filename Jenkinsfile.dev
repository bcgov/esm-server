library identifier: 'devops-library@master', retriever: modernSCM(
  [$class: 'GitSCMSource',
   remote: 'https://github.com/BCDevOps/jenkins-pipeline-shared-lib.git'])

// Edit your app's name below
def APP_NAME = 'esm-server-dev'
// def PATHFINDER_URL = "pathfinder.gov.bc.ca"
// Edit your environment TAG names below
def TAG_NAMES = [
  'dev'
]
// def APP_URLS = [
//   "https://${APP_NAME}-${TAG_NAMES[0]}.${PATHFINDER_URL}"
// ]
def APP_URLS = [
  "https://esm-master.pathfinder.gov.bc.ca/"
]

// You shouldn't have to edit these if you're following the conventions
def ARTIFACT_BUILD = APP_NAME + '-build'
def IMAGESTREAM_NAME = APP_NAME
def SLACK_DEV_CHANNEL = "#developers"

def hasRepoChanged = false;
node{
  def lastCommit = getLastCommit()
  if(lastCommit != null){
    // Ensure our CHANGE variables are set
    if(env.CHANGE_AUTHOR_DISPLAY_NAME == null){
      env.CHANGE_AUTHOR_DISPLAY_NAME = lastCommit.author.fullName
    }

    if(env.CHANGE_TITLE == null){
      env.CHANGE_TITLE = lastCommit.msg
    }
    hasRepoChanged = true;
  }else{
    hasRepoChanged = false;
  }
}

if(hasRepoChanged){
  stage('Build ' + APP_NAME) {
    node{
      try{
        echo "Building: " + ARTIFACT_BUILD
        openshiftBuild bldCfg: ARTIFACT_BUILD, showBuildLogs: 'true'
        
        // Don't tag with BUILD_ID so the pruner can do it's job; it won't delete tagged images.
        // Tag the images for deployment based on the image's hash
        IMAGE_HASH = sh (
          script: """oc get istag ${IMAGESTREAM_NAME}:latest -o template --template=\"{{.image.dockerImageReference}}\"|awk -F \":\" \'{print \$3}\'""",
          returnStdout: true).trim()
        echo ">> IMAGE_HASH: ${IMAGE_HASH}"
      }catch(error){
        slackNotify(
          'Build Broken ü§ï',
          "The latest ${APP_NAME} build seems to have broken\n'${error.message}'",
          'danger',
          env.SLACK_HOOK,
          SLACK_DEV_CHANNEL,
          [
            [
              type: "button",
              text: "View Build Logs",
              style:"danger",           
              url: "${currentBuild.absoluteUrl}/console"
            ]
          ])
        throw error
      }
    }
  }

  stage('Deploy ' + TAG_NAMES[0]) {
    def environment = TAG_NAMES[0]
    def url = APP_URLS[0]
    node{
      try{
        openshiftTag destStream: IMAGESTREAM_NAME, verbose: 'true', destTag: environment, srcStream: IMAGESTREAM_NAME, srcTag: "${IMAGE_HASH}"
        slackNotify(
            "New Version in ${environment} üöÄ",
            "A new version of the ${APP_NAME} is now in ${environment}",
            'good',
            env.SLACK_HOOK,
            SLACK_DEV_CHANNEL,
            [
              [
                type: "button",
                text: "View New Version",         
                url: "${url}"
              ],
              [
                type: "button",            
                text: "Deploy to Test?",
                style: "primary",              
                url: "${currentBuild.absoluteUrl}/input"
              ]
            ])
      }catch(error){
        slackNotify(
          "Couldn't deploy to ${environment} ü§ï",
          "The latest deployment of the ${APP_NAME} to ${environment} seems to have failed\n'${error.message}'",
          'danger',
          env.SLACK_HOOK,
          SLACK_DEV_CHANNEL,
          [
            [
              type: "button",
              text: "View Build Logs",
              style:"danger",        
              url: "${currentBuild.absoluteUrl}/console"
            ]
          ])
      }
    }
  }
}else{
  stage('No Changes to Build üëç'){
    currentBuild.result = 'SUCCESS'
  }
}
